import { PromiseClient } from '@connectrpc/connect';
import { PartialMessage } from '@bufbuild/protobuf';
import { submit, syncConnect, cardano, queryConnect, submitConnect, watchConnect, query } from '@utxorpc/spec';

type GenericTipEvent<Block, Point> = {
    action: "apply";
    block: Block;
} | {
    action: "undo";
    block: Block;
} | {
    action: "reset";
    point: Point;
};
type GenericTxEvent<Tx> = {
    action: "apply";
    Tx: Tx | undefined;
} | {
    action: "undo";
    Tx: Tx | undefined;
};
type GenericTxInMempoolEvent<Tx> = {
    stage: submit.Stage;
    txoRef: Uint8Array;
    nativeBytes: Uint8Array;
    Tx: Tx | undefined;
};
type GenericUtxo<Ref, Parsed> = {
    txoRef: Ref;
    parsedValued: Parsed | undefined;
    nativeBytes: Uint8Array | undefined;
};
type ClientBuilderOptions = {
    uri: string;
    headers?: Record<string, string>;
};

type ChainPoint = {
    slot: number | string;
    hash: string;
};
type Utxo = GenericUtxo<query.TxoRef, cardano.TxOutput>;
type TipEvent = GenericTipEvent<cardano.Block, ChainPoint>;
type TxEvent = GenericTxEvent<cardano.Tx>;
type MempoolEvent = GenericTxInMempoolEvent<cardano.Tx>;
type TxHash = Uint8Array;
type TxCbor = Uint8Array;
declare class SyncClient {
    inner: PromiseClient<typeof syncConnect.SyncService>;
    constructor(options: ClientBuilderOptions);
    followTip(intersect?: ChainPoint[]): AsyncIterable<TipEvent>;
    readTip(): Promise<ChainPoint>;
    fetchBlock(p: ChainPoint): Promise<cardano.Block>;
    fetchHistory(p: ChainPoint, maxItems?: number): Promise<cardano.Block>;
}
declare class QueryClient {
    inner: PromiseClient<typeof queryConnect.QueryService>;
    constructor(options: ClientBuilderOptions);
    readParams(): Promise<cardano.PParams>;
    readUtxosByOutputRef(refs: {
        txHash: Uint8Array;
        outputIndex: number;
    }[]): Promise<Utxo[]>;
    private searchUtxosByMatch;
    searchUtxosByAddress(address: Uint8Array): Promise<Utxo[]>;
    searchUtxosByPaymentPart(paymentPart: Uint8Array): Promise<Utxo[]>;
    searchUtxosByDelegationPart(delegationPart: Uint8Array): Promise<Utxo[]>;
    searchUtxosByAsset(policyId?: Uint8Array, name?: Uint8Array): Promise<Utxo[]>;
    searchUtxosByAddressWithAsset(address: Uint8Array, policyId?: Uint8Array, name?: Uint8Array): Promise<Utxo[]>;
    searchUtxosByPaymentPartWithAsset(paymentPart: Uint8Array, policyId?: Uint8Array, name?: Uint8Array): Promise<Utxo[]>;
    searchUtxosByDelegationPartWithAsset(delegationPart: Uint8Array, policyId?: Uint8Array, name?: Uint8Array): Promise<Utxo[]>;
}
declare class SubmitClient {
    inner: PromiseClient<typeof submitConnect.SubmitService>;
    constructor(options: ClientBuilderOptions);
    submitTx(tx: TxCbor): Promise<TxHash>;
    evalTx(tx: TxCbor): Promise<submit.EvalTxResponse>;
    waitForTx(txHash: TxHash): AsyncIterable<submit.Stage>;
    watchMempoolByMatch(pattern: PartialMessage<cardano.TxPattern>): AsyncIterable<MempoolEvent>;
    watchMempool(): AsyncIterable<MempoolEvent>;
    watchMempoolForAddress(address: Uint8Array): AsyncIterable<MempoolEvent>;
    watchMempoolForPaymentPart(paymentPart: Uint8Array): AsyncIterable<MempoolEvent>;
    watchMempoolForDelegationPart(delegationPart: Uint8Array): AsyncIterable<MempoolEvent>;
    watchMempoolForAsset(policyId?: Uint8Array, assetName?: Uint8Array): AsyncIterable<MempoolEvent>;
}
declare class WatchClient {
    inner: PromiseClient<typeof watchConnect.WatchService>;
    constructor(options: ClientBuilderOptions);
    watchTxByMatch(pattern: PartialMessage<cardano.TxPattern>, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTx(intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTxForAddress(address: Uint8Array, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTxForPaymentPart(paymentPart: Uint8Array, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTxForDelegationPart(delegationPart: Uint8Array, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTxForAsset(policyId?: Uint8Array, assetName?: Uint8Array, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
}

export { QueryClient as CardanoQueryClient, SubmitClient as CardanoSubmitClient, SyncClient as CardanoSyncClient, WatchClient as CardanoWatchClient };
