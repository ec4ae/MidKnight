// src/functions/crypto/index.ts
import { Crypto as WebCrypto } from "@peculiar/webcrypto";

// src/functions/crypto/encryption.ts
var IV_LENGTH = 16;
async function encryptWithCipher({
  data,
  key,
  algorithm = "AES-GCM",
  initializationVectorSize = IV_LENGTH
}) {
  const keyMaterial = await crypto2.subtle.importKey(
    "raw",
    new TextEncoder().encode(key),
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );
  const cryptoKey = await crypto2.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: new Uint8Array(initializationVectorSize),
      // Use a fixed salt for simplicity
      iterations: 1e5,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: algorithm, length: 256 },
    false,
    ["encrypt"]
  );
  const iv = crypto2.getRandomValues(new Uint8Array(initializationVectorSize));
  const encrypted = await crypto2.subtle.encrypt(
    { name: algorithm, iv },
    cryptoKey,
    new TextEncoder().encode(data)
  );
  return JSON.stringify({
    iv: Buffer.from(iv).toString("base64"),
    ciphertext: Buffer.from(encrypted).toString("base64")
  });
}
async function decryptWithCipher({
  encryptedDataJSON,
  key,
  algorithm = "AES-GCM"
}) {
  const _encryptedData = JSON.parse(encryptedDataJSON);
  const keyMaterial = await crypto2.subtle.importKey(
    "raw",
    new TextEncoder().encode(key),
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );
  const cryptoKey = await crypto2.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: new Uint8Array(Buffer.from(_encryptedData.iv, "base64").length),
      // Use the same salt size as IV
      iterations: 1e5,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: algorithm, length: 256 },
    false,
    ["decrypt"]
  );
  const decodedIv = Buffer.from(_encryptedData.iv, "base64");
  const decodedEncryptedData = Buffer.from(_encryptedData.ciphertext, "base64");
  const decrypted = await crypto2.subtle.decrypt(
    { name: algorithm, iv: decodedIv },
    cryptoKey,
    decodedEncryptedData
  );
  return new TextDecoder().decode(decrypted);
}
async function generateKeyPair() {
  const keyPair = await crypto2.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-256"
    },
    true,
    ["deriveKey"]
  );
  const publicKey = await crypto2.subtle.exportKey("spki", keyPair.publicKey);
  const privateKey = await crypto2.subtle.exportKey("pkcs8", keyPair.privateKey);
  const key = {
    publicKey: Buffer.from(publicKey).toString("base64"),
    privateKey: Buffer.from(privateKey).toString("base64")
  };
  return key;
}
async function encryptWithPublicKey({
  publicKey,
  data
}) {
  const publicKeyBuffer = Buffer.from(publicKey, "base64");
  const _publicKey = await crypto2.subtle.importKey(
    "spki",
    publicKeyBuffer,
    { name: "ECDH", namedCurve: "P-256" },
    false,
    []
  );
  const ephemeralKeyPair = await crypto2.subtle.generateKey(
    { name: "ECDH", namedCurve: "P-256" },
    true,
    ["deriveKey"]
  );
  const sharedSecret = await crypto2.subtle.deriveKey(
    { name: "ECDH", public: _publicKey },
    ephemeralKeyPair.privateKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );
  const iv = crypto2.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto2.subtle.encrypt(
    { name: "AES-GCM", iv },
    sharedSecret,
    new TextEncoder().encode(data)
  );
  const encryptedData = {
    ephemeralPublicKey: await crypto2.subtle.exportKey(
      "spki",
      ephemeralKeyPair.publicKey
    ),
    iv,
    ciphertext: encrypted
  };
  return JSON.stringify({
    ephemeralPublicKey: Buffer.from(encryptedData.ephemeralPublicKey).toString(
      "base64"
    ),
    iv: Buffer.from(encryptedData.iv).toString("base64"),
    ciphertext: Buffer.from(encryptedData.ciphertext).toString("base64")
  });
}
async function decryptWithPrivateKey({
  privateKey,
  encryptedDataJSON
}) {
  const privateKeyBuffer = Buffer.from(privateKey, "base64");
  const _encryptedData = JSON.parse(encryptedDataJSON);
  const encryptedData = {
    ephemeralPublicKey: Buffer.from(
      _encryptedData.ephemeralPublicKey,
      "base64"
    ),
    iv: Buffer.from(_encryptedData.iv, "base64"),
    ciphertext: Buffer.from(_encryptedData.ciphertext, "base64")
  };
  const _privateKey = await crypto2.subtle.importKey(
    "pkcs8",
    privateKeyBuffer,
    { name: "ECDH", namedCurve: "P-256" },
    false,
    ["deriveKey"]
  );
  const ephemeralPublicKey = await crypto2.subtle.importKey(
    "spki",
    encryptedData.ephemeralPublicKey,
    { name: "ECDH", namedCurve: "P-256" },
    false,
    []
  );
  const sharedSecret = await crypto2.subtle.deriveKey(
    { name: "ECDH", public: ephemeralPublicKey },
    _privateKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["decrypt"]
  );
  const decrypted = await crypto2.subtle.decrypt(
    { name: "AES-GCM", iv: encryptedData.iv },
    sharedSecret,
    encryptedData.ciphertext
  );
  return new TextDecoder().decode(decrypted);
}

// src/functions/crypto/hash.ts
import * as crypto3 from "crypto";
function generateHash({
  size = 64
}) {
  return new Promise((resolve, reject) => {
    crypto3.randomBytes(size, function(err, buffer) {
      resolve(buffer.toString("hex"));
    });
  });
}
async function hashData({
  data,
  privateKey = "",
  algorithm = "sha256"
}) {
  return new Promise((resolve, reject) => {
    const hmac = crypto3.createHmac(algorithm, privateKey);
    hmac.on("readable", () => {
      const data2 = hmac.read();
      if (data2) {
        resolve(data2.toString("hex"));
      }
    });
    hmac.write(data);
    hmac.end();
  });
}

// src/functions/crypto/index.ts
var crypto2;
if (typeof window !== "undefined" && window.crypto && window.crypto.subtle) {
  crypto2 = window.crypto;
} else if (typeof global !== "undefined") {
  const webCrypto = new WebCrypto();
  crypto2 = webCrypto;
} else {
  throw new Error("Web Crypto API is not supported in this environment.");
}

// src/functions/key-shard/combine-shards-build-wallet.ts
import { MeshWallet } from "@meshsdk/wallet";

// src/functions/key-shard/shamir-secret-sharing.ts
function getRandomBytes(numBytes) {
  return crypto.getRandomValues(new Uint8Array(numBytes));
}
var LOG_TABLE = new Uint8Array([
  0,
  255,
  200,
  8,
  145,
  16,
  208,
  54,
  90,
  62,
  216,
  67,
  153,
  119,
  254,
  24,
  35,
  32,
  7,
  112,
  161,
  108,
  12,
  127,
  98,
  139,
  64,
  70,
  199,
  75,
  224,
  14,
  235,
  22,
  232,
  173,
  207,
  205,
  57,
  83,
  106,
  39,
  53,
  147,
  212,
  78,
  72,
  195,
  43,
  121,
  84,
  40,
  9,
  120,
  15,
  33,
  144,
  135,
  20,
  42,
  169,
  156,
  214,
  116,
  180,
  124,
  222,
  237,
  177,
  134,
  118,
  164,
  152,
  226,
  150,
  143,
  2,
  50,
  28,
  193,
  51,
  238,
  239,
  129,
  253,
  48,
  92,
  19,
  157,
  41,
  23,
  196,
  17,
  68,
  140,
  128,
  243,
  115,
  66,
  30,
  29,
  181,
  240,
  18,
  209,
  91,
  65,
  162,
  215,
  44,
  233,
  213,
  89,
  203,
  80,
  168,
  220,
  252,
  242,
  86,
  114,
  166,
  101,
  47,
  159,
  155,
  61,
  186,
  125,
  194,
  69,
  130,
  167,
  87,
  182,
  163,
  122,
  117,
  79,
  174,
  63,
  55,
  109,
  71,
  97,
  190,
  171,
  211,
  95,
  176,
  88,
  175,
  202,
  94,
  250,
  133,
  228,
  77,
  138,
  5,
  251,
  96,
  183,
  123,
  184,
  38,
  74,
  103,
  198,
  26,
  248,
  105,
  37,
  179,
  219,
  189,
  102,
  221,
  241,
  210,
  223,
  3,
  141,
  52,
  217,
  146,
  13,
  99,
  85,
  170,
  73,
  236,
  188,
  149,
  60,
  132,
  11,
  245,
  230,
  231,
  229,
  172,
  126,
  110,
  185,
  249,
  218,
  142,
  154,
  201,
  36,
  225,
  10,
  21,
  107,
  58,
  160,
  81,
  244,
  234,
  178,
  151,
  158,
  93,
  34,
  136,
  148,
  206,
  25,
  1,
  113,
  76,
  165,
  227,
  197,
  49,
  187,
  204,
  31,
  45,
  59,
  82,
  111,
  246,
  46,
  137,
  247,
  192,
  104,
  27,
  100,
  4,
  6,
  191,
  131,
  56
]);
var EXP_TABLE = new Uint8Array([
  1,
  229,
  76,
  181,
  251,
  159,
  252,
  18,
  3,
  52,
  212,
  196,
  22,
  186,
  31,
  54,
  5,
  92,
  103,
  87,
  58,
  213,
  33,
  90,
  15,
  228,
  169,
  249,
  78,
  100,
  99,
  238,
  17,
  55,
  224,
  16,
  210,
  172,
  165,
  41,
  51,
  89,
  59,
  48,
  109,
  239,
  244,
  123,
  85,
  235,
  77,
  80,
  183,
  42,
  7,
  141,
  255,
  38,
  215,
  240,
  194,
  126,
  9,
  140,
  26,
  106,
  98,
  11,
  93,
  130,
  27,
  143,
  46,
  190,
  166,
  29,
  231,
  157,
  45,
  138,
  114,
  217,
  241,
  39,
  50,
  188,
  119,
  133,
  150,
  112,
  8,
  105,
  86,
  223,
  153,
  148,
  161,
  144,
  24,
  187,
  250,
  122,
  176,
  167,
  248,
  171,
  40,
  214,
  21,
  142,
  203,
  242,
  19,
  230,
  120,
  97,
  63,
  137,
  70,
  13,
  53,
  49,
  136,
  163,
  65,
  128,
  202,
  23,
  95,
  83,
  131,
  254,
  195,
  155,
  69,
  57,
  225,
  245,
  158,
  25,
  94,
  182,
  207,
  75,
  56,
  4,
  185,
  43,
  226,
  193,
  74,
  221,
  72,
  12,
  208,
  125,
  61,
  88,
  222,
  124,
  216,
  20,
  107,
  135,
  71,
  232,
  121,
  132,
  115,
  60,
  189,
  146,
  201,
  35,
  139,
  151,
  149,
  68,
  220,
  173,
  64,
  101,
  134,
  162,
  164,
  204,
  127,
  236,
  192,
  175,
  145,
  253,
  247,
  79,
  129,
  47,
  91,
  234,
  168,
  28,
  2,
  209,
  152,
  113,
  237,
  37,
  227,
  36,
  6,
  104,
  179,
  147,
  44,
  111,
  62,
  108,
  10,
  184,
  206,
  174,
  116,
  177,
  66,
  180,
  30,
  211,
  73,
  233,
  156,
  200,
  198,
  199,
  34,
  110,
  219,
  32,
  191,
  67,
  81,
  82,
  102,
  178,
  118,
  96,
  218,
  197,
  243,
  246,
  170,
  205,
  154,
  160,
  117,
  84,
  14,
  1
]);
function add(a, b) {
  if (!Number.isInteger(a) || a < 0 || a > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  return a ^ b;
}
function div(a, b) {
  if (!Number.isInteger(a) || a < 0 || a > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (b === 0) {
    throw new Error("cannot divide by zero");
  }
  const logA = LOG_TABLE[a];
  const logB = LOG_TABLE[b];
  const diff = (logA - logB + 255) % 255;
  const result = EXP_TABLE[diff];
  return a === 0 ? 0 : result;
}
function mult(a, b) {
  if (!Number.isInteger(a) || a < 0 || a > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  const logA = LOG_TABLE[a];
  const logB = LOG_TABLE[b];
  const sum = (logA + logB) % 255;
  const result = EXP_TABLE[sum];
  return a === 0 || b === 0 ? 0 : result;
}
function interpolatePolynomial(xSamples, ySamples, x) {
  if (xSamples.length !== ySamples.length) {
    throw new Error("sample length mistmatch");
  }
  const limit = xSamples.length;
  let basis = 0;
  let result = 0;
  for (let i = 0; i < limit; i++) {
    basis = 1;
    for (let j = 0; j < limit; ++j) {
      if (i === j) {
        continue;
      }
      const num = add(x, xSamples[j]);
      const denom = add(xSamples[i], xSamples[j]);
      const term = div(num, denom);
      basis = mult(basis, term);
    }
    result = add(result, mult(ySamples[i], basis));
  }
  return result;
}
function evaluate(coefficients, x, degree) {
  if (x === 0) {
    throw new Error("cannot evaluate secret polynomial at zero");
  }
  let result = coefficients[degree];
  for (let i = degree - 1; i >= 0; i--) {
    const coefficient = coefficients[i];
    result = add(mult(result, x), coefficient);
  }
  return result;
}
function getRandomByte() {
  return getRandomBytes(1)[0];
}
function getNonZeroRandomByte() {
  while (true) {
    const byte = getRandomByte();
    if (byte > 0) {
      return byte;
    }
  }
}
function newCoefficients(intercept, degree) {
  const coefficients = new Uint8Array(degree + 1);
  coefficients[0] = intercept;
  for (let i = 1; i <= degree; i++) {
    const coefficientTMinus1 = i === degree;
    coefficients[i] = coefficientTMinus1 ? getNonZeroRandomByte() : getRandomByte();
  }
  return coefficients;
}
function newCoordinates() {
  const coordinates = new Uint8Array(255);
  for (let i = 0; i < 255; i++) {
    coordinates[i] = i + 1;
  }
  const randomIndices = getRandomBytes(255);
  for (let i = 0; i < 255; i++) {
    const j = randomIndices[i] % 255;
    const temp = coordinates[i];
    coordinates[i] = coordinates[j];
    coordinates[j] = temp;
  }
  return coordinates;
}
var AssertArgument = {
  instanceOf(object, constructor, message) {
    if (object.constructor !== constructor) {
      throw new TypeError(message);
    }
  },
  inRange(n, start, until, message) {
    if (!(start < until && n >= start && n < until)) {
      throw new RangeError(message);
    }
  },
  greaterThanOrEqualTo(a, b, message) {
    if (a < b) {
      throw new Error(message);
    }
  },
  equalTo(a, b, message) {
    if (a !== b) {
      throw new Error(message);
    }
  }
};
async function shamirSplit(secret, shares, threshold) {
  AssertArgument.instanceOf(secret, Uint8Array, "secret must be a Uint8Array");
  AssertArgument.greaterThanOrEqualTo(secret.byteLength, 1, "secret cannot be empty");
  AssertArgument.instanceOf(shares, Number, "shares must be a number");
  AssertArgument.inRange(shares, 2, 256, "shares must be at least 2 and at most 255");
  AssertArgument.instanceOf(threshold, Number, "threshold must be a number");
  AssertArgument.inRange(threshold, 2, 256, "threshold must be at least 2 and at most 255");
  AssertArgument.greaterThanOrEqualTo(shares, threshold, "shares cannot be less than threshold");
  const result = [];
  const secretLength = secret.byteLength;
  const xCoordinates = newCoordinates();
  for (let i = 0; i < shares; i++) {
    const share = new Uint8Array(secretLength + 1);
    share[secretLength] = xCoordinates[i];
    result.push(share);
  }
  const degree = threshold - 1;
  for (let i = 0; i < secretLength; i++) {
    const byte = secret[i];
    const coefficients = newCoefficients(byte, degree);
    for (let j = 0; j < shares; ++j) {
      const x = xCoordinates[j];
      const y = evaluate(coefficients, x, degree);
      result[j][i] = y;
    }
  }
  return result;
}
async function shamirCombine(shares) {
  AssertArgument.instanceOf(shares, Array, "shares must be an Array");
  AssertArgument.inRange(
    shares.length,
    2,
    256,
    "shares must have at least 2 and at most 255 elements"
  );
  const share1 = shares[0];
  AssertArgument.instanceOf(share1, Uint8Array, "each share must be a Uint8Array");
  for (const share of shares) {
    AssertArgument.instanceOf(share, Uint8Array, "each share must be a Uint8Array");
    AssertArgument.greaterThanOrEqualTo(share.byteLength, 2, "each share must be at least 2 bytes");
    AssertArgument.equalTo(
      share.byteLength,
      share1.byteLength,
      "all shares must have the same byte length"
    );
  }
  const sharesLength = shares.length;
  const shareLength = share1.byteLength;
  const secretLength = shareLength - 1;
  const secret = new Uint8Array(secretLength);
  const xSamples = new Uint8Array(sharesLength);
  const ySamples = new Uint8Array(sharesLength);
  const samples = /* @__PURE__ */ new Set();
  for (let i = 0; i < sharesLength; i++) {
    const share = shares[i];
    const sample = share[shareLength - 1];
    if (samples.has(sample)) {
      throw new Error("shares must contain unique values but a duplicate was found");
    }
    samples.add(sample);
    xSamples[i] = sample;
  }
  for (let i = 0; i < secretLength; i++) {
    for (let j = 0; j < sharesLength; ++j) {
      ySamples[j] = shares[j][i];
    }
    secret[i] = interpolatePolynomial(xSamples, ySamples, 0);
  }
  return secret;
}

// src/functions/convertors.ts
function stringToBytes(data) {
  return new TextEncoder().encode(data);
}
function bytesToString(data) {
  return new TextDecoder().decode(data);
}
function bytesToHex(bytes) {
  return Array.from(bytes).map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
function hexToBytes(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

// src/functions/key-shard/combine-shards-build-wallet.ts
async function combineShardsBuildWallet(networkId, keyShard1, keyShard2) {
  const _share1 = hexToBytes(keyShard1);
  const _share2 = hexToBytes(keyShard2);
  const reconstructed = await shamirCombine([_share1, _share2]);
  const key = bytesToString(reconstructed);
  const wallet = new MeshWallet({
    networkId,
    key: {
      type: "mnemonic",
      words: key.split(" ")
    }
  });
  await wallet.init();
  return { key, wallet };
}

// src/functions/key-shard/get-address-from-hashes.ts
import { pubKeyAddress } from "@meshsdk/common";
import { serializeAddressObj } from "@meshsdk/core-cst";
function getAddressFromHashes(pubKeyHash, stakeCredentialHash, networkId) {
  return serializeAddressObj(
    pubKeyAddress(pubKeyHash, stakeCredentialHash),
    networkId
  );
}

// src/functions/key-shard/spilt-key-into-shards.ts
async function spiltKeyIntoShards(key) {
  const secret = stringToBytes(key);
  const [share1, share2, share3] = await shamirSplit(secret, 3, 2);
  const keyShare1 = bytesToHex(share1);
  const keyShare2 = bytesToHex(share2);
  const keyShare3 = bytesToHex(share3);
  return [keyShare1, keyShare2, keyShare3];
}

// src/functions/client/derive-wallet.ts
async function clientDeriveWallet(encryptedKeyShard, spendingPassword, custodialShard, networkId) {
  const keyShare1 = await decryptWithCipher({
    encryptedDataJSON: encryptedKeyShard,
    key: spendingPassword
  });
  const keyShare2 = custodialShard;
  const { wallet } = await combineShardsBuildWallet(
    networkId,
    keyShare1,
    keyShare2
  );
  return wallet;
}

// src/functions/client/generate-wallet.ts
import { MeshWallet as MeshWallet2 } from "@meshsdk/wallet";
import { generateMnemonic } from "@meshsdk/common";
import { deserializeBech32Address } from "@meshsdk/core-cst";
async function clientGenerateWallet(spendingPassword, recoveryAnswer) {
  const mnemonic = await generateMnemonic(256);
  const wallet = new MeshWallet2({
    networkId: 1,
    key: {
      type: "mnemonic",
      words: mnemonic.split(" ")
    }
  });
  await wallet.init();
  const addresses = await wallet.getAddresses();
  const keyHashes = deserializeBech32Address(addresses.baseAddressBech32);
  const [keyShare1, keyShare2, keyShare3] = await spiltKeyIntoShards(mnemonic);
  const encryptedAuthKey = await encryptWithCipher({
    data: keyShare1,
    key: spendingPassword
  });
  const encryptedRecoveryKey = await encryptWithCipher({
    data: keyShare3,
    key: recoveryAnswer
  });
  return {
    pubKeyHash: keyHashes.pubKeyHash,
    stakeCredentialHash: keyHashes.stakeCredentialHash,
    deviceKey: encryptedAuthKey,
    authKey: keyShare2,
    recoveryKey: encryptedRecoveryKey
  };
}

// src/functions/client/recovery.ts
async function clientRecovery(authShard, recoveryShard, recoveryAnswer, spendingPassword, newRecoveryAnswer) {
  try {
    const answer = recoveryAnswer.replace(/[^a-zA-Z0-9]/g, "").toLocaleLowerCase();
    const recoverKeyShare3 = await decryptWithCipher({
      encryptedDataJSON: recoveryShard,
      key: answer
    });
    const recoverKeyShare2 = authShard;
    const { key } = await combineShardsBuildWallet(
      0,
      // dont care about network here
      recoverKeyShare2,
      recoverKeyShare3
    );
    const [keyShare1, keyShare2, keyShare3] = await spiltKeyIntoShards(key);
    const encryptedAuthKey = await encryptWithCipher({
      data: keyShare1,
      key: spendingPassword
    });
    const newAnswer = newRecoveryAnswer.replace(/[^a-zA-Z0-9]/g, "").toLocaleLowerCase();
    const encryptedRecoveryKey = await encryptWithCipher({
      data: keyShare3,
      key: newAnswer
    });
    return {
      deviceKey: encryptedAuthKey,
      authKey: keyShare2,
      recoveryKey: encryptedRecoveryKey
    };
  } catch (e) {
    console.error(e);
    throw new Error("Invalid recovery answer");
  }
}

// src/functions/window/open-window.ts
async function openWindow(url, params, appUrl = "https://web3.meshjs.dev/") {
  const _url = `${appUrl}${url}?params=${JSON.stringify(params)}`;
  return new Promise((resolve, reject) => {
    const windowFeatures = "left=200,top=100,width=400,height=550,toolbar=no,menubar=no,scrollbars=no,resizable=no,location=no,status=no";
    const newWindow = window.open(_url, "mesh", windowFeatures);
    if (!newWindow) {
      return reject(new Error("Failed to open window"));
    }
    newWindow.document.title = "Mesh Web3 Services";
    const interval = setInterval(() => {
      if (newWindow.closed) {
        clearInterval(interval);
        resolve({ success: false, message: "Window was closed by the user" });
      }
    }, 500);
    window.addEventListener("message", (event) => {
      if (event.data.target === "mesh") {
        clearInterval(interval);
        newWindow.close();
        resolve(event.data);
      }
    });
  });
}

// src/sdk/index.ts
import axios from "axios";

// src/sdk/wallet-developer-controlled/index.ts
import { MeshWallet as MeshWallet3 } from "@meshsdk/wallet";
import { deserializeBech32Address as deserializeBech32Address2 } from "@meshsdk/core-cst";
import { v4 as uuidv4 } from "uuid";
var WalletDeveloperControlled = class {
  sdk;
  constructor({ sdk }) {
    {
      this.sdk = sdk;
    }
  }
  /**
   * Creates a new wallet associated with the current project.
   * This method generates a new wallet encrypts it with the project's public key, and registers the wallet with the backend service.
   *
   * @param {Object} [options] - Optional parameters for wallet creation.
   * @param {string} [options.tag] - An optional tag to associate with the wallet.
   *
   * @returns {Promise<MeshWallet>} A promise that resolves to the created wallet instance.
   *
   * @throws {Error} If the project's public key is not found.
   * @throws {Error} If the wallet creation request to the backend fails.
   */
  async createWallet({
    tags
  } = {}) {
    const project = await this.sdk.getProject();
    if (!project.publicKey) {
      throw new Error("Project public key not found");
    }
    const mnemonic = MeshWallet3.brew();
    const encryptedMnemonic = await encryptWithPublicKey({
      publicKey: project.publicKey,
      data: mnemonic.join(" ")
    });
    const _wallet = new MeshWallet3({
      networkId: 1,
      key: {
        type: "mnemonic",
        words: mnemonic
      },
      fetcher: this.sdk.providerFetcher,
      submitter: this.sdk.providerSubmitter
    });
    await _wallet.init();
    const addresses = await _wallet.getAddresses();
    const baseAddressBech32 = addresses.baseAddressBech32;
    const { pubKeyHash, stakeCredentialHash } = deserializeBech32Address2(baseAddressBech32);
    const web3Wallet = {
      id: uuidv4(),
      // todo, to be removed should be generated at DB
      key: encryptedMnemonic,
      tags: tags || [],
      projectId: this.sdk.projectId,
      pubKeyHash,
      stakeCredentialHash
    };
    const { data, status } = await this.sdk.axiosInstance.post(
      `api/project-wallet`,
      web3Wallet
    );
    if (status === 200) {
      return data;
    }
    throw new Error("Failed to create wallet");
  }
  /**
   * Retrieves a list of wallets associated with the current project.
   *
   * @returns {Promise<Web3ProjectWallet[]>} A promise that resolves to an array of wallets,
   * each containing the wallet's `id`, `address`, `networkId`, and `tag`.
   *
   * @throws {Error} Throws an error if the request to fetch wallets fails.
   */
  async getWallets() {
    const { data, status } = await this.sdk.axiosInstance.get(
      `api/project-wallet/${this.sdk.projectId}`
    );
    if (status === 200) {
      return data;
    }
    throw new Error("Failed to get wallets");
  }
  /**
   * Retrieves a wallet by its ID and decrypts the key with the project's private key.
   *
   * @param walletId - The unique identifier of the wallet to retrieve.
   * @returns A promise that resolves to an initialized `MeshWallet` instance.
   * @throws Will throw an error if the private key is not found or if the wallet retrieval fails.
   */
  async getWallet(walletId, networkId) {
    if (this.sdk.privateKey === void 0) {
      throw new Error("Private key not found");
    }
    const { data, status } = await this.sdk.axiosInstance.get(
      `api/project-wallet/${this.sdk.projectId}/${walletId}`
    );
    if (status === 200) {
      const web3Wallet = data;
      const mnemonic = await decryptWithPrivateKey({
        privateKey: this.sdk.privateKey,
        encryptedDataJSON: web3Wallet.key
      });
      const wallet = new MeshWallet3({
        networkId,
        key: {
          type: "mnemonic",
          words: mnemonic.split(" ")
        },
        fetcher: this.sdk.providerFetcher,
        submitter: this.sdk.providerSubmitter
      });
      await wallet.init();
      return { info: web3Wallet, wallet };
    }
    throw new Error("Failed to get wallet");
  }
};

// src/sdk/index.ts
var Web3Sdk = class {
  axiosInstance;
  appUrl;
  projectId;
  apiKey;
  privateKey;
  project;
  providerFetcher;
  providerSubmitter;
  wallet;
  constructor({
    appUrl,
    projectId,
    apiKey,
    privateKey,
    fetcher,
    submitter
  }) {
    {
      this.appUrl = appUrl ? appUrl : "https://web3.meshjs.dev/";
      this.projectId = projectId;
      this.apiKey = apiKey;
      this.privateKey = privateKey;
      this.providerFetcher = fetcher;
      this.providerSubmitter = submitter;
      this.axiosInstance = axios.create({
        baseURL: this.appUrl,
        headers: { "x-api-key": apiKey }
      });
      this.wallet = new WalletDeveloperControlled({
        sdk: this
      });
    }
  }
  async getProject() {
    if (this.project) {
      return this.project;
    }
    const { data, status } = await this.axiosInstance.get(
      `api/project/${this.projectId}`
    );
    if (status === 200) {
      this.project = data;
      return this.project;
    }
    throw new Error("Failed to get project");
  }
};

// src/wallet-user-controlled/index.ts
import { MeshWallet as MeshWallet4 } from "@meshsdk/wallet";
var Web3Wallet = class _Web3Wallet extends MeshWallet4 {
  projectId;
  appUrl;
  user;
  constructor(options) {
    super(options);
    this.projectId = options.projectId;
    this.appUrl = options.appUrl;
    this.user = options.user;
  }
  /**
   * Initializes a new instance of the Web3Wallet class.
   *
   * @param options - The options to initialize the wallet.
   * @param options.networkId - The network ID (0 for testnet, 1 for mainnet).
   * @param options.fetcher - An optional fetcher for network requests.
   * @param options.submitter - An optional submitter for transaction submissions.
   * @param options.projectId - An optional project ID for analytics or tracking.
   * @param options.appUrl - An optional application URL for the wallet.
   * @param options.directTo - An optional parameter to specify the user-controlled wallet direct-to option.
   *
   * @returns A promise that resolves to an instance of Web3Wallet.
   */
  static async enable(options) {
    const res = await getWalletFromWindow({
      networkId: options.networkId,
      projectId: options.projectId,
      appUrl: options.appUrl,
      directTo: options.directTo
    });
    if (res.success === false)
      throw new ApiError({
        code: -3,
        info: "Refused - The request was refused due to lack of access - e.g. wallet disconnects."
      });
    const address = getAddressFromHashes(
      res.pubKeyHash,
      res.stakeCredentialHash,
      options.networkId
    );
    const wallet = await _Web3Wallet.initWallet({
      networkId: options.networkId,
      address,
      fetcher: options.fetcher,
      submitter: options.submitter,
      projectId: options.projectId,
      appUrl: options.appUrl,
      user: res.user
    });
    return wallet;
  }
  getUser() {
    return this.user;
  }
  /**
   * Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.
   *
   * @param unsignedTx - a transaction in CBOR
   * @param partialSign - if the transaction is partially signed (default: false)
   * @returns a signed transaction in CBOR
   */
  async signTx(unsignedTx, partialSign = false) {
    const _payload = {
      method: "sign-tx",
      unsignedTx,
      networkId: await this.getNetworkId(),
      projectId: this.projectId
    };
    const res = await openWindow(
      "/client/sign-tx",
      _payload,
      this.appUrl
    );
    if (res.success === false)
      throw new ApiError({
        code: 2,
        info: "UserDeclined - User declined to sign the transaction."
      });
    return res.tx;
  }
  /**
   * This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.
   *
   * @param payload - the payload to sign
   * @param address - the address to use for signing (optional)
   * @returns a signature
   */
  async signData(payload, address) {
    if (address === void 0) {
      address = await this.getChangeAddress();
    }
    const _payload = {
      method: "sign-data",
      payload,
      networkId: await this.getNetworkId(),
      projectId: this.projectId
    };
    const res = await openWindow(
      "/client/sign-data",
      _payload,
      this.appUrl
    );
    if (res.success === false)
      throw new ApiError({
        code: 3,
        info: "UserDeclined - User declined to sign the data."
      });
    return res.signature;
  }
  /**
   * Initializes a new instance of a Web3 wallet with the specified options.
   *
   * @param params - The parameters required to initialize the wallet.
   * @param params.networkId - The network ID to connect to. Must be either `0` (testnet) or `1` (mainnet).
   * @param params.address - The wallet address to associate with the wallet instance.
   * @param params.fetcher - (Optional) An implementation of the `IFetcher` interface for fetching data.
   * @param params.submitter - (Optional) An implementation of the `ISubmitter` interface for submitting transactions.
   * @param params.projectId - (Optional) The project ID for analytics or tracking purposes.
   * @param params.appUrl - (Optional) The application URL for associating the wallet with a specific app.
   *
   * @returns A promise that resolves to an initialized instance of `Web3Wallet`.
   */
  static async initWallet({
    networkId,
    address,
    fetcher,
    submitter,
    projectId,
    appUrl,
    user
  }) {
    const _options = {
      networkId,
      key: {
        type: "address",
        address
      },
      fetcher,
      submitter,
      projectId,
      appUrl,
      user
    };
    const wallet = new _Web3Wallet(_options);
    await wallet.init();
    return wallet;
  }
};
var ApiError = class extends Error {
  json;
  constructor(json) {
    super(json.info || "An error occurred");
    this.name = "ApiError";
    this.json = json;
  }
};
async function getWalletFromWindow({
  networkId,
  projectId,
  appUrl,
  directTo
}) {
  const payload = {
    networkId,
    projectId,
    directTo
  };
  const walletRes = await openWindow(
    "/client/wallet",
    payload,
    appUrl
  );
  if (walletRes.user) {
    walletRes.user.id = walletRes.user.id.replace(
      /discord|twitter|google/g,
      ""
    );
  }
  if (walletRes.success) {
    return walletRes;
  }
  return {
    success: false,
    error: {
      errorMessage: "No wallet"
    }
  };
}
export {
  ApiError,
  Web3Sdk,
  Web3Wallet,
  bytesToHex,
  bytesToString,
  clientDeriveWallet,
  clientGenerateWallet,
  clientRecovery,
  combineShardsBuildWallet,
  crypto2 as crypto,
  decryptWithCipher,
  decryptWithPrivateKey,
  encryptWithCipher,
  encryptWithPublicKey,
  generateHash,
  generateKeyPair,
  getAddressFromHashes,
  getWalletFromWindow,
  hashData,
  hexToBytes,
  openWindow,
  shamirCombine,
  shamirSplit,
  spiltKeyIntoShards,
  stringToBytes
};
